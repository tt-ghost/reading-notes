## go语言第一课

> 慕课网学习教程

### 程序实体与关键字

- 名字首字母为大写的程序实体可以被任何代码包中的代码访问到。
- 而名字首字母为小写的程序实体则只能被同一个代码包中的代码所访问。 

### 关键字

|用途|关键字|
|----|-----|
|程序申明|import, package|
|程序实体声明和定义|chan, const, func, interface, map, struct, type, var|
|程序流程控制|go, select, break, case, continue, default, defer, else, faultthrough, for, goto, if, range, return, switch|

### 变量和常量

- var 用于变量申明，可以申明不赋值
- const 用于常量申明，申明必须赋值

```go
var num1 int = 1
// 或
var num2, num3 int = 2, 3
// 或
var ( // 多行赋值
  num4 int = 4
  num4 int = 5
)
```

### 整数类型的命名和宽度

- Go语言的整数类型一共有10个
> 其中计算架构相关的整数类型有两个，即：有符号的整数类型`int`和无符号的整数类型`uint`，随着计算机架构的不同而不同

|数据类型|计算架构|类型宽度(比特)|类型宽度(字节)|
|------|-------|------------|------------|
|init|32位|32|4|
|init|64位|64|8|
|uinit|32位|32|4|
|uinit|64位|64|8|

另外8个可以显式表达自身宽度的整数类型

|数据类型|有符号|类型宽度(比特)|
|------|-----|------------|
|init8|是|8|
|init16|是|16|
|init32|是|32|
|init64|是|64|
|uinit8|否|8|
|uinit16|否|16|
|uinit32|否|32|
|uinit64|否|64|

- 有符号的整数类型会使用最高位的比特（bit）表示整数的正负
- 无符号的整数类型会使用所有的比特位来表示数值

### 整数类型值表示法

> int8的数值表示范围为[-128, 127]，类型uint16表示[0,65535]

- 十进制表示 `var num1 int = 12`
- 八进制表示 `num1 = 014` ，其中'0'为八进制前缀
- 十六进制表示 `num1 = 0xC`，其中'0x'为十六进制前缀

注：为已声明的变量赋值，无需再在等号左边加入关键字var和变量类型

### 浮点数类型

> 类型有两个： `float32`和`float64`，存储分别占用4个和8个字节

- 浮点数值可以被简化，`37.0`简写为`37`，`0.037`简化为`.037`
- go中，浮点数的相关部分只能由10进制表示法表示，不能由8或16进制表示，如`03.7`一定表示浮点数`3.7`

### 复数类型

- 分为两种类型：`complex64`和`complex128`，存储分别占用8个和16个字节
- `complex64`由两个`float32`类型的值分别表示复数的实数部分和虚数部分
- `complex128`由两个`float64`类型的值分别表示复数的实数部分和虚数部分

### byte与rune

- 它们都属于别名类型。`byte`是`uint8`的别名类型，而`rune`则是`int32`的别名类型
- byte类型的值需用8个比特位表示，其表示法与uint8类型无异
- rune类型的值需要由单引号“'”包裹
- 我们还可以用另外几种形式表示rune类型值，如下：

|示例|备注|关键字|
|---|---|------|
|直接使用Unicode字符|'郝'表示中文字符'郝'|只能表示Unicode支持的字符|
|"\x"加两个十六进制数|"\x41"表示英文字符"A"|只能表示ASCII编码支持的字符|
|"\"加三位八进制数|"\101"表示英文字符"A"|只能表示编码在[0,255)内的字符|
|"\u"加四位十六进制数|"\u90DD"表示'郝'|只能表示编码在[0,65535)内的字符|
|"\U"加四位十六进制数|"\U000090DD"表示'郝'|可以表示任何Unicode字符|

### 字符串类型

- 字符串的表示法有两种，即：原生表示法和解释型表示法。
- 若用原生表示法，需用反引号“`”把字符序列包裹起来。若用解释型表示法，则需用双引号“"”包裹字符序列。

### 数组类型

- 数组内类型相同，长度固定，申明一个数组类型如下：

```go
// 3为长度，int为元素类型，类型申明用关键字type
type MyNumbers [3]int
```
- 数组表示方式

```go
[3]int{1,2,3}
// 赋值
var numbers = [3]int{1,2,3}
// 也可以这样，不用数数组长度了
var numbers = [...]int{1,2,3}
// 取值方式
numbers[0] //第一个元素
// 这种取值方式可应用于字符串、数组、切片或字典类型的值
// 修改值
numbers[0] = 3
```

- `len`获取字符串、数组、切片、字典或通道类型的值的长度

```go
var length = len(numbers)
```

- 若申明不赋值，则值都为`0`

```go
var numbers2 [5]int
// numbers 值为
[5]int{0, 0, 0, 0, 0}
```

### 切片类型

-  切片（Slice）与数组一样，也是可以容纳若干类型相同的元素的容器。与数组不同的是，无法通过切片类型来确定其值的长度。每个切片值都会将数组作为其底层数据结构

```go
// 表示切片类型的字面量
[]int
// 或
[]string
```
- 定义别名类型

```go
type MySlice []int
// 切片表示
[]int{1, 2, 3}
```
- 另一种操作数组的方式叫切片

切片表达式一般由字符串、数组或切片的值以及由方括号包裹且由英文冒号“:”分隔的两个正整数组成。这两个正整数分别表示元素下界索引和元素上界索引

```go
var number3 = [5]int{1,2,3,4,5}
var slice1 = number3[1:4]
// 结果为 []int{2,3,4,5}
```

切片表达式的求值结果会是切片类型的，且其元素类型与被“切片”的值的元素类型一致。还可以对切片进行切片：

```go
var slice2 = slice1[1:3] 
```

 - 切片和数组的另一个属性：容量。数组的容量总是等于其长度，切片容量为第一个元在其底层数组中的索引值与该数组长度差值的绝对值。
 - 获取容量的有系统内部函数： `cap`
 
 ```go
 var capacity2 int = cap(slice2)
 ```
 - 切片类型属于引用类型，它的零值为`nil`即空值。
 - 如果只申明切片类型而不为它赋值，那么该变量值将为 `nil`:
 
 ```go
 var slice3 []int
 // 值即为 nil
 ```
 
 ### 切片的更多操作方法
 
 ```go
 numbers3[1:4:4]
 ```
 
- 第三个正整数被称为容量上界索引。它的意义在于可以把作为结果的切片值的容量设置得更小
 
```go
var numbers3 = [5]int{1, 2, 3, 4, 5}
var slice1 = numbers3[1:4] 
// 如下操作将其长度延展得与其容量相同
slice1 = slice1[:cap(slice1)]
```
以上 `slice1` 为 `[]int{2, 3, 4, 5}`,长度和容量均为4

- `append` 会对切片值进行扩展并返回一个新的切片值

```go
slice1 = append(slice1, 6, 7)
// slice1 为 []int{2, 3, 4, 6, 7}
```
 一旦扩展操作超出了被操作的切片值的容量，那么该切片的底层数组就会被自动更换
 
- `copy`函数接受两个类型相同的切片值作为参数，并会把第二个参数值中的元素复制到第一个参数值中的相应位置（索引值相同）上
 - 这种复制遵循最小复制原则，即：被复制的元素的个数总是等于长度较短的那个参数值的长度。
 - 与append函数不同，copy函数会直接对其第一个参数值进行修改
 
```go
var slice4 = []int{0, 0, 0, 0, 0, 0, 0}
copy(slice4, slice1) 
// slice4 为 []int{2, 3, 4, 6, 7, 0, 0}
 ```

### 字典类型

> Go语言的字典（Map）类型其实是哈希表（Hash Table）的一个实现(键-值对)

- 字面量形式 `map[K]T`,`K`为键的类型，而`T`则代表元素（或称值）的类型，如：

```go
map[int]string
```

- 字典的键类型必须是可比较的，否则会引起错误。也就是说，它不能是切片、字典或函数类型。

```go
// 声明
mm := map[int]string{1: "a", 2: "b", 3: "c"}
// 取值
b := mm[2]
// b 为字符串 "b"
// 添加一个值
mm[4] = ""

// 取值
d := mm[4]
e := mm[5]
// d和e都为空字符串""
```
- 对于字典值来说，如果其中不存在索引表达式欲取出的键值对，那么就以它的值类型的空值（或称默认值）作为该索引表达式的求值结果。因此无法知道某一个键对应的值是空字符串还是没有

```go
e, ok := mm[5]
// 这种方式ok为false,因为没有键为5的值
```

- 删除键值

```go
delete(mm, 4) 
```

- 与切片类型相同，字典类型属于引用类型。它的零值即为`nil`

### 通道类型

> 它可用于在不同Goroutine之间传递类型化的数据，并且是并发安全的,可以被看做是承载可被并发执行的代码块的载体。它们由Go语言的运行时系统调度，并依托操作系统线程（又称内核线程）来并发地执行其中的代码块

- 表示方法

```go
chan T
// chan 为关键字，T为允许传递的元素类型
```

- 只能通过内建函数`make`来表示通道类型的值，接受两个参数，第一个参数是代表了将被初始化的值的类型的字面量（比如chan int），而第二个参数则是值的长度

```go
make(chan int, 5)
```

- 通道值的长度被称为其缓存的尺寸。代表着通道值中可以暂存的数据的个数。注意，暂存在通道值中的数据是先进先出的

```go
ch1 := make(chan string, 5)
```

- `<-`用来接受和发送数据

```go
// 向ch1 发送字符串 "value1"
ch1 <- "value1"
// 把接收到的字符串赋给一个变量
value := <- ch1
// 通道类型也可接受第二个参数，与字典用法一样，ok表示通道的状态，true为通道值有效，false为无效或称已关闭
value, ok := <- ch1
```

- 更深层次的原因是，如果在接收操作进行之前或过程中通道值被关闭了，则接收操作会立即结束并返回一个该通道值的元素类型的零值。按照上面的第一种写法，我们无从判断接收到零值的原因是什么。
- 通过`clode`关闭通道

```go
close(ch1)
```
- **注意**
 - 请注意，对通道值的重复关闭会引发运行时恐慌。这会使程序崩溃。所以一定要避免这种情况的发生。
 - 另外，在通道值有效的前提下，针对它的发送操作会在通道值已满（其中缓存的数据的个数已等于它的长度）时被阻塞。而向一个已被关闭的通道值发送数据会引发运行时恐慌。
 - 另一方面，针对有效通道值的接收操作会在它已空（其中没有缓存任何数据）时被阻塞。除此之外，还有几条与通道的发送和接收操作有关的规则。

- 与切片和字典类型相同，通道类型属于引用类型。它的零值即为`nil`

### 通道的更多种类

- 通道有带缓冲和非缓冲之分
- 缓冲通道中可以缓存N个数据。我们在初始化一个通道值的时候必须指定这个N。相对的，非缓冲通道不会缓存任何数据。
- **发送方在向通道值发送数据的时候会立即被阻塞，直到有某一个接收方已从该通道值中接收了这条数据。**

非缓冲的通道值的初始化方法

```go
make(chan int, 0)
```
